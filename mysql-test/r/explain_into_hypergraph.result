#
# WL#15588 Store EXPLAIN FORMAT=JSON SELECT output in user variable.
#
SET @v1 = 'UNCHANGED';
SET @v2 = @v1;

# Unsupported functionality.
EXPLAIN ANALYZE FORMAT=JSON INTO @v1 SELECT 1;
ERROR 0A000: EXPLAIN ANALYZE does not support the INTO clause.
EXPLAIN INTO @v1 SELECT 1;
ERROR 0A000: EXPLAIN INTO does not support implicit FORMAT.
EXPLAIN FORMAT=TRADITIONAL INTO @v1 SELECT 1;
ERROR 0A000: EXPLAIN INTO does not support FORMAT=TRADITIONAL.
EXPLAIN FORMAT=TREE INTO @v1 SELECT 1;
ERROR 0A000: EXPLAIN INTO does not support FORMAT=TREE.
# Check that the variable was not changed on error.
SELECT @v1, @v1 = @v2;
@v1	@v1 = @v2
UNCHANGED	1

CREATE TABLE t1 (i1 int, i2 int);
CREATE TABLE t2 (i3 int, i4 int);
INSERT INTO t1 VALUES (1,2), (2,3), (3,4);
INSERT INTO t2 SELECT i2, i1 FROM t1;
ANALYZE TABLE t1, t2;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
test.t2	analyze	status	OK

# Simple SELECT.
EXPLAIN FORMAT=JSON INTO @v1 SELECT * FROM t1 JOIN t2 ON i1 = i3 WHERE i2 = 2;
EXPLAIN
SELECT @v1, JSON_VALID(@v1) from dual;
@v1	JSON_VALID(@v1)
{
  "query": "/* select#1 */ select `test`.`t1`.`i1` AS `i1`,`test`.`t1`.`i2` AS `i2`,`test`.`t2`.`i3` AS `i3`,`test`.`t2`.`i4` AS `i4` from `test`.`t1` join `test`.`t2` where ((`test`.`t1`.`i2` = 2) and (`test`.`t1`.`i1` = `test`.`t2`.`i3`))",
  "inputs": [
    {
      "inputs": [
        {
          "operation": "Table scan on t1",
          "table_name": "t1",
          "access_type": "table",
          "estimated_rows": 3.0,
          "estimated_total_cost": 0.25,
          "estimated_first_row_cost": 0.08333333333333333
        }
      ],
      "condition": "(t1.i2 = 2)",
      "operation": "Filter: (t1.i2 = 2)",
      "access_type": "filter",
      "estimated_rows": 0.30000000447034836,
      "estimated_total_cost": 0.55,
      "estimated_first_row_cost": 0.55
    },
    {
      "inputs": [
        {
          "operation": "Table scan on t2",
          "table_name": "t2",
          "access_type": "table",
          "estimated_rows": 3.0,
          "estimated_total_cost": 0.25,
          "estimated_first_row_cost": 0.08333333333333333
        }
      ],
      "condition": "(t1.i1 = t2.i3)",
      "operation": "Filter: (t1.i1 = t2.i3)",
      "access_type": "filter",
      "estimated_rows": 0.30000000447034836,
      "estimated_total_cost": 0.55,
      "estimated_first_row_cost": 0.55
    }
  ],
  "join_type": "inner join",
  "operation": "Nested loop inner join",
  "access_type": "join",
  "estimated_rows": 0.09000000268220903,
  "join_algorithm": "nested_loop",
  "estimated_total_cost": 1.1,
  "estimated_first_row_cost": 1.1
}	1

# User variable is overwritten on successful execution.
SET @v2 = @v1;
EXPLAIN FORMAT=JSON INTO @v1 SELECT * FROM t1;
EXPLAIN
SELECT JSON_VALID(@v1), @v1 != @v2, @v1 NOT LIKE CONCAT(@v2, '%');
JSON_VALID(@v1)	@v1 != @v2	@v1 NOT LIKE CONCAT(@v2, '%')
1	1	1
DROP TABLE t1, t2;
SET @v1=NULL, @v2=NULL;
